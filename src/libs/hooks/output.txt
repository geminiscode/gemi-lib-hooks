// usePropTypes/validadores/Constants.tsx



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/*MAIN ------------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



const Consts_Validadores = {
  types: {
    string: "string",
    number: "number",
    bigint: "bigint",
    boolean: "boolean",
    undefined: "undefined",
    null: "null",
    symbol: "symbol",
    array: "array",
    object: "object",
    instanceof: "instanceof",
  },
} as const;



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/*EXPORT ----------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



export {Consts_Validadores};
// usePropTypes/validadores/Types.tsx
//Types.tsx
/**
 *  -   En este archivo se definen los tipos de validadores que se utilizan en la librería de validación de propiedades.
 *  -   Estos tipos son utilizados para definir la estructura de los validadores y asegurar que se cumplan las 
 *  expectativas de entrada y salida.
 */
import { Consts_Validadores } from "./Constants";
import { Validadores_Array } from "./Validadores_Array";
import { Validadores_BigInt } from "./Validadores_BigInt";
import { Validadores_Boolean } from "./Validadores_Boolean";
import { Validadores_InstanceOf } from "./Validadores_InstanceOf";
import { Validadores_Number } from "./Validadores_Number";
import { Validadores_Object } from "./Validadores_Object";
import { Validadores_String } from "./Validadores_String";
import { Validadores_Symbol } from "./Validadores_Symbol";



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* TYPES ----------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



// Definición de respuesta para los validadores
export type Type_Validadores_Response_Basic = true | string;

// Tipo para cada campo del esquema: string | number | boolean, etc.
export type Type_Validador_Elemento = Interface_Validadores[keyof Interface_Validadores];

// Tipo para cada validacion de esquema que genere una respuesta
export type Type_Validador_Elemento_Response = string | undefined;



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* INTERFACES -----------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



// Interfaz para validar funciones que pueden recibir 1 o 2 argumentos
export interface Type_Validadores {
    // Versión básica: solo valor
    (valor: unknown): Type_Validadores_Response_Basic;

    // Versión extendida: valor + esquema u otro dato
    (valor: unknown, esquema: any): Type_Validadores_Response_Basic;
}

// Interfaz para conjunto de validaciones
export interface Interface_Validadores {
    string: typeof Validadores_String & { type: typeof Consts_Validadores.types.string };
    number: typeof Validadores_Number & { type: typeof Consts_Validadores.types.number };
    bigint: typeof Validadores_BigInt & { type: typeof Consts_Validadores.types.bigint };
    boolean: typeof Validadores_Boolean & { type: typeof Consts_Validadores.types.boolean };
    symbol: typeof Validadores_Symbol & { type: typeof Consts_Validadores.types.symbol };
    array: typeof Validadores_Array & { type: typeof Consts_Validadores.types.array };
    instanceof: typeof Validadores_InstanceOf & { type: typeof Consts_Validadores.types.instanceof };
    object: typeof Validadores_Object & { type: typeof Consts_Validadores.types.object };
}
// usePropTypes/validadores/Utils.tsx
import { Interface_Validadores, Type_Validador_Elemento, Type_Validador_Elemento_Response } from "./Validadores";



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/*METHODS ---------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



// Función para obtener el tipo del validador
export function getValidatorType(validator: Type_Validador_Elemento): Type_Validador_Elemento_Response {
    if ('type' in validator) {
      return (validator as { type: string }).type;
    }
    return undefined;
}

/* Función para validar si es o no un validador */
export function isValidValidators(schemas: Interface_Validadores[keyof Interface_Validadores][] | Interface_Validadores[keyof Interface_Validadores]): Type_Validador_Elemento_Response {
    const schemasArray = Array.isArray(schemas) ? schemas : [schemas];
    const types = schemasArray.map(getValidatorType);

    //validar que los validadores sean válidos
    if (types.some(type => type === undefined)) {
        //indicar cual es el validador inválido especificando su posición y nombre
        const invalidIndex = types.findIndex(type => type === undefined);
        // obtener el nombre del validador inválido
        const invalidValidatorName = schemasArray[invalidIndex]?.name || 'desconocido';
        // retornar un mensaje de error indicando el validador inválido
        return `Error: El validador en la posición [${invalidIndex}] (${invalidValidatorName}) no es válido.`;
    }

    return undefined;
}
// usePropTypes/validadores/Validadores.tsx
// Validadores.tsx
import { Consts_Validadores } from "./Constants";
import { Interface_Validadores, Type_Validador_Elemento, Type_Validador_Elemento_Response } from "./Types";
import { Validadores_Array } from "./Validadores_Array";
import { Validadores_BigInt } from "./Validadores_BigInt";
import { Validadores_Boolean } from "./Validadores_Boolean";
import { Validadores_InstanceOf } from "./Validadores_InstanceOf";
import { Validadores_Number } from "./Validadores_Number";
import { Validadores_Object } from "./Validadores_Object";
import { Validadores_String } from "./Validadores_String";
import { Validadores_Symbol } from "./Validadores_Symbol";



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* TYPES ----------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/




/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/*INTERFACES ------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/





/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/*MAIN ------------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



const Validadores: Interface_Validadores = {
    string: Validadores_String,
    number: Validadores_Number,
    bigint: Validadores_BigInt,
    boolean: Validadores_Boolean,
    symbol: Validadores_Symbol,
    array: Validadores_Array,
    instanceof: Validadores_InstanceOf,
    object: Validadores_Object,
};



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/*EXPORT ----------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



export type { Interface_Validadores, Type_Validador_Elemento, Type_Validador_Elemento_Response };
export default Validadores;
// usePropTypes/validadores/Validadores_Array.tsx




/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* TYPES ----------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/

import { Consts_Validadores } from "./Constants";
import { Interface_Validadores, Type_Validadores_Response_Basic } from "./Types";
import { getValidatorType, isValidValidators } from "./Utils";



// -- no apply



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* INTERFACES -----------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



/**
 * Configuración del validador de arrays.
 */
interface Config {
    /**
     * Indica si el array puede estar vacío.
     * @default false
     */
    optionalEmpty?: boolean;

    /**
     * Longitud mínima permitida del array.
     * @default 0
     */
    minLength?: number;

    /**
     * Longitud máxima permitida del array.
     * @default Infinity
     */
    maxLength?: number;
}



/**
 * Interfaz principal del validador de arrays.
 *
 * Se puede invocar directamente o encadenar métodos como `.minLength()`, `.of()` etc.
 */
interface Interface_Validadores_Array {
    /**
     * Valida que el valor sea un array y cumpla con las condiciones definidas.
     * @param valor - Valor a validar.
     * @returns `true` si es válido, sino un mensaje de error.
     */
    (valor: unknown): Type_Validadores_Response_Basic;

    /**
     * Permite que el array esté vacío.
     * @returns Función de validación actualizada.
     */
    optionalEmpty(): Interface_Validadores_Array;

    /**
     * Valida que el array tenga al menos la longitud especificada.
     * @param length - Longitud mínima requerida.
     * @returns Función de validación actualizada.
     */
    minLength(length: number): Interface_Validadores_Array;

    /**
     * Valida que el array no exceda la longitud especificada.
     * @param length - Longitud máxima permitida.
     * @returns Función de validación actualizada.
     */
    maxLength(length: number): Interface_Validadores_Array;

    /**
     * Valida que todos los elementos del array sean del **mismo tipo/validador**.
     * @param schema - Un único validador que deben cumplir **todos** los elementos.
     * @returns Función de validación encadenable.
     */
    ofOne(
        schema: Interface_Validadores[keyof Interface_Validadores]
    ): Interface_Validadores_Array;

    /**
     * Valida que cada elemento del array cumpla **con al menos uno** de los validadores dados.
     * @param schemas - Lista de validadores para comprobar cada elemento.
     * @returns Función de validación encadenable.
     */
    ofAny(
        ...schemas: Interface_Validadores[keyof Interface_Validadores][]
    ): Interface_Validadores_Array;
    
    /**
     * Configura opciones avanzadas del validador.
     * @param config - Objeto con configuraciones como `minLength`, `maxLength`, etc.
     * @returns Función de validación actualizada.
     */
    __config(config: Partial<Config>): Interface_Validadores_Array;

    /**
     * Tipo de validador.
     */
    type: typeof Consts_Validadores.types.array;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* BUILDER --------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



function Build_Validadores_Array(): Interface_Validadores_Array {



    /* MAIN -------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    const validar = (valor: unknown): Type_Validadores_Response_Basic => {
        if (!Array.isArray(valor)) {
            return "Error: El valor proporcionado no es un array.";
        }
        return true;
    };



    /* CHAINABLE UTILITY ------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    function chainable(
        nuevaValidacion: (valor: unknown) => Type_Validadores_Response_Basic
    ): Interface_Validadores_Array {
        const combinedValidator = (valor: unknown): Type_Validadores_Response_Basic => {
            const baseResult = validar(valor);
            if (typeof baseResult === 'string') return baseResult;
            return nuevaValidacion(valor);
        };

        return Object.assign(combinedValidator, {
            optionalEmpty: () => chainable((valor) => {
                const result = combinedValidator(valor);
                if (typeof result === 'string') return result;
                const arr = valor as unknown[];
                if (arr.length === 0) return true;
                return result;
            }),

            minLength: (length: number) => chainable((valor) => {
                const result = combinedValidator(valor);
                if (typeof result === 'string') return result;
                const arr = valor as unknown[];
                if (arr.length < length) {
                    return `Error: El array debe tener al menos ${length} elementos.`;
                }
                return true;
            }),

            maxLength: (length: number) => chainable((valor) => {
                const result = combinedValidator(valor);
                if (typeof result === 'string') return result;
                const arr = valor as unknown[];
                if (arr.length > length) {
                    return `Error: El array no puede tener más de ${length} elementos.`;
                }
                return true;
            }),

            ofOne: (schema: Interface_Validadores[keyof Interface_Validadores]) => {
                return chainable((valor) => {
                    const result = combinedValidator(valor);
                    const isValid = isValidValidators(schema);
                    if (typeof result === 'string') return result;
                    if (typeof isValid === 'string') return isValid;

                    const arr = valor as unknown[];
                    const validator = schema as (value: unknown) => Type_Validadores_Response_Basic;

                    for (let i = 0; i < arr.length; i++) {
                        const element = arr[i];
                        const res = validator(element);

                        if (res !== true) {
                            return `Error en indice ${i}: ${res}`;
                        }
                    }

                    return true;
                });
            },

            ofAny: (...schemas: Interface_Validadores[keyof Interface_Validadores][]) => {
                return chainable((valor) => {
                    const result = combinedValidator(valor);
                    const isValid = isValidValidators(schemas);
                    if (typeof result === 'string') return result;
                    if (typeof isValid === 'string') return isValid;

                    const arr = valor as unknown[];
                    
                    for (let i = 0; i < arr.length; i++) {

                        const element = arr[i];
                        let isValid = false;
                        let firstError: string | null = null;

                        for (const schema of schemas) {
                            const validator = schema as (value: unknown) => Type_Validadores_Response_Basic;
                            const res = validator(element);

                            if (res === true) {
                                isValid = true;
                                break;
                            } else if (!firstError && typeof res === 'string') {
                                firstError = res;
                            }
                        }

                        if (!isValid) {
                            const allowedTypes = schemas.map(getValidatorType).join(', ');
                            const receivedType = typeof element;
                            return `
                            Error en posición [${i}]: Tipo "${receivedType}" no permitido. Se esperaba: ${allowedTypes}. Valor recibido: ${element}
                            ${firstError ? `Detalle: ${firstError}` : ''}
                            `;
                        }
                    }

                    return true;
                });
            },

            __config: (config: Partial<Config>) => chainable((valor) => {
                const result = combinedValidator(valor);
                if (typeof result === 'string') return result;

                const arr = valor as unknown[];

                if (config.minLength !== undefined && arr.length < config.minLength) {
                    return `Error: El array debe tener al menos ${config.minLength} elementos.`;
                }

                if (config.maxLength !== undefined && arr.length > config.maxLength) {
                    return `Error: El array no puede tener más de ${config.maxLength} elementos.`;
                }

                if (!config.optionalEmpty && arr.length === 0) {
                    return "Error: El array no puede estar vacío.";
                }

                return true;
            }),

            type: Consts_Validadores.types.array,
        }) as Interface_Validadores_Array;
    }



    /* CHAINED METHODS --------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    // -- no apply



    /* RETURN ------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/

    

    return chainable(validar) as Interface_Validadores_Array;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* EXPORT ---------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



export type { Interface_Validadores_Array };
export const Validadores_Array = Build_Validadores_Array();
// usePropTypes/validadores/Validadores_BigInt.tsx
import { Consts_Validadores } from './Constants';
import type { Type_Validadores_Response_Basic } from './Types';



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* TYPES ----------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



// -- no apply



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* INTERFACES -----------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



interface Interface_Validadores_BigInt {
    /**
     * Valida que el valor sea exactamente un `bigint`.
     * @param valor - Valor a validar.
     * @returns true si es bigint, sino un mensaje de error.
     */
    (valor: unknown): Type_Validadores_Response_Basic;

    /**
     * Valida que el valor NO sea null/undefined y sea `bigint`.
     * @param mensaje - Mensaje opcional de error.
     * @returns Función de validación encadenable.
     */
    required(mensaje?: string): Interface_Validadores_BigInt;

    /**
     * Valida que el valor sea mayor o igual a cierto número.
     * @param numero - Valor mínimo (number o bigint).
     * @param mensaje - Mensaje opcional de error.
     * @returns Función de validación encadenable.
     */
    min(numero: number | bigint, mensaje?: string): Interface_Validadores_BigInt;

    /**
     * Valida que el valor sea menor o igual a cierto número.
     * @param numero - Valor máximo (number o bigint).
     * @param mensaje - Mensaje opcional de error.
     * @returns Función de validación encadenable.
     */
    max(numero: number | bigint, mensaje?: string): Interface_Validadores_BigInt;

    /**
     * Tipo de validador.
     * @returns El tipo de validador.
     */
    type: typeof Consts_Validadores.types.bigint;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* BUILDER --------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



function Build_Validadores_BigInt(): Interface_Validadores_BigInt {



    /* MAIN -------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    const validar = (valor: unknown): Type_Validadores_Response_Basic => {
        if (typeof valor !== 'bigint') {
            return 'Error: El valor debe ser `bigint`.';
        }
        return true;
    };



    /* CHAINABLE UTILITY ------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    function chainable(
        nuevaValidacion: (valor: unknown) => Type_Validadores_Response_Basic
    ): Interface_Validadores_BigInt {
        const combinedValidator = (valor: unknown): Type_Validadores_Response_Basic => {
            // Primero valida que sea `bigint`
            const baseResult = validar(valor);
            if (typeof baseResult === 'string') return baseResult;

            // Luego aplica la nueva regla
            return nuevaValidacion(valor);
        };

        return Object.assign(combinedValidator, {
            required: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    if (valor === null || valor === undefined) {
                        return mensaje || 'Error: Este campo es requerido.';
                    }

                    return true;
                }),

            min: (numero: number | bigint, mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const big = valor as bigint;
                    const limite = BigInt(numero);

                    if (big < limite) {
                        return mensaje || `Error: Debe ser mayor o igual a ${limite}n.`;
                    }

                    return true;
                }),

            max: (numero: number | bigint, mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const big = valor as bigint;
                    const limite = BigInt(numero);

                    if (big > limite) {
                        return mensaje || `Error: Debe ser menor o igual a ${limite}n.`;
                    }

                    return true;
                }),

            type: Consts_Validadores.types.bigint,
        }) as Interface_Validadores_BigInt;
    }



    /* CHAINED METHODS --------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    // -- no apply



    /* RETURN -----------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    return chainable(validar) as Interface_Validadores_BigInt;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* EXPORT ---------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



export type { Interface_Validadores_BigInt };
export const Validadores_BigInt = Build_Validadores_BigInt();
// usePropTypes/validadores/Validadores_Boolean.tsx
// Validadores_Boolean.tsx
import { Consts_Validadores } from './Constants';
import type { Type_Validadores_Response_Basic } from './Types';



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* INTERFACES -----------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



interface Interface_Validadores_Boolean {
    /**
     * Valida que el valor sea un booleano.
     * @param valor - Valor a validar.
     * @returns true si es un booleano válido, sino un mensaje de error.
     */
    (valor: unknown): Type_Validadores_Response_Basic;

    /**
     * Valida que el valor no sea null ni undefined.
     * @param mensaje - Mensaje opcional de error si falla la validación.
     * @returns Función de validación.
     */
    required(mensaje?: string): Interface_Validadores_Boolean;

    /**
     * Valida que el valor sea exactamente `true`.
     * @param mensaje - Mensaje opcional de error si falla la validación.
     * @returns Función de validación.
     */
    true(mensaje?: string): Interface_Validadores_Boolean;

    /**
     * Valida que el valor sea exactamente `false`.
     * @param mensaje - Mensaje opcional de error si falla la validación.
     * @returns Función de validación.
     */
    false(mensaje?: string): Interface_Validadores_Boolean;

    /**
     * Valida con una función personalizada.
     * @param fn - Función de validación personalizada.
     * @returns Función de validación.
     */
    custom(fn: (value: boolean) => Type_Validadores_Response_Basic): Interface_Validadores_Boolean;

    /**
     * Tipo de validador.
     * @returns El tipo de validador.
     */
    type: typeof Consts_Validadores.types.boolean;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* BUILDER --------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



function Build_Validadores_Boolean(): Interface_Validadores_Boolean {



    /*MAIN --------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    const validar = (valor: unknown): Type_Validadores_Response_Basic => {
        if (typeof valor !== 'boolean') {
            return 'Error: El valor proporcionado no es un booleano.';
        }
        return true;
    };



    /*CHAINABLED BUILDER ------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    function chainable(
        nuevaValidacion: (valor: unknown) => Type_Validadores_Response_Basic
    ): Interface_Validadores_Boolean {
        const combinedValidator = (valor: unknown): Type_Validadores_Response_Basic => {
            // Primero valida que sea boolean
            const baseResult = validar(valor);
            if (typeof baseResult === 'string') return baseResult;

            // Luego aplica la nueva regla
            return nuevaValidacion(valor);
        };

        return Object.assign(combinedValidator, {
            required: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    if (valor === null || valor === undefined) {
                        return mensaje || 'Error: Este campo es requerido.';
                    }

                    return true;
                }),

            true: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const bool = valor as boolean;

                    if (bool !== true) {
                        return mensaje || 'Error: El valor debe ser verdadero.';
                    }

                    return true;
                }),

            false: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const bool = valor as boolean;

                    if (bool !== false) {
                        return mensaje || 'Error: El valor debe ser falso.';
                    }

                    return true;
                }),

            custom: (fn: (value: boolean) => Type_Validadores_Response_Basic) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const bool = valor as boolean;

                    return fn(bool);
                }),

            type: Consts_Validadores.types.boolean,
        }) as Interface_Validadores_Boolean;
    }



    /*CHAINED METHODS ---------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    // -- no apply



    /*RETURN ------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    return chainable(validar) as Interface_Validadores_Boolean;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* EXPORT ---------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



export type { Interface_Validadores_Boolean };
export const Validadores_Boolean = Build_Validadores_Boolean();
// usePropTypes/validadores/Validadores_InstanceOf.tsx
// Validadores_InstanceOf.tsx
import { Consts_Validadores } from './Constants';
import type { Type_Validadores_Response_Basic } from './Types';



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* INTERFACES -----------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



interface Interface_Validadores_InstanceOf {
    /**
     * Valida que el valor sea una instancia de una clase específica.
     * @param valor - Valor a validar.
     * @returns true si es válido, sino un mensaje de error.
     */
    (valor: unknown): Type_Validadores_Response_Basic;

    /**
     * Establece la clase esperada para la validación.
     * @param clase - Clase a comparar (ej. Date, Promise).
     * @param mensaje - Mensaje opcional si falla la validación.
     * @returns Función de validación encadenable.
     */
    instanceOf<T>(clase: new (...args: any[]) => T, mensaje?: string): Interface_Validadores_InstanceOf;

    /**
     * Establece la clase prohibida para la validación.
     * @param clase - Clase a excluir (ej. String, Array).
     * @param mensaje - Mensaje opcional si falla la validación.
     * @returns Función de validación encadenable.
     */
    notInstanceOf<T>(clase: new (...args: any[]) => T, mensaje?: string): Interface_Validadores_InstanceOf;

    /**
     * Tipo de validador.
     */
    type: typeof Consts_Validadores.types.instanceof;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* BUILDER --------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



function Build_Validadores_InstanceOf(): Interface_Validadores_InstanceOf {



    /*MAIN --------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    const validar = (valor: unknown): Type_Validadores_Response_Basic => {
        if (valor === null || valor === undefined) {
            return 'Error: El valor no puede ser null ni undefined.';
        }
        return true;
    };



    /*CHAINABLED BUILDER ------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    function chainable(
        nuevaValidacion: (valor: unknown) => Type_Validadores_Response_Basic
    ): Interface_Validadores_InstanceOf {
        const combinedValidator = (valor: unknown): Type_Validadores_Response_Basic => {
            // Primero valida que no sea null/undefined
            const baseResult = validar(valor);
            if (typeof baseResult === 'string') return baseResult;

            // Luego aplica la nueva regla
            return nuevaValidacion(valor);
        };

        return Object.assign(combinedValidator, {
            instanceOf: createInstanceOfMethod(combinedValidator),
            notInstanceOf: createNotInstanceOfMethod(combinedValidator),
            type: Consts_Validadores.types.instanceof,
        }) as Interface_Validadores_InstanceOf;
    }



    /*CHAINED METHODS ---------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    function createInstanceOfMethod(
        combinedValidator: (valor: unknown) => Type_Validadores_Response_Basic
    ): <T>(clase: new (...args: any[]) => T, mensaje?: string) => Interface_Validadores_InstanceOf {
        return function <T>(
            clase: new (...args: any[]) => T,
            mensaje?: string
        ): Interface_Validadores_InstanceOf {
            return chainable((valor) => {
                const result = combinedValidator(valor);
                if (typeof result === 'string') return result;

                const className = clase.name || 'Clase desconocida';
                const receivedType = valor?.constructor?.name || typeof valor;

                if (!(valor instanceof clase)) {
                    return mensaje || `Error: El valor debe ser una instancia de ${className}, pero se recibió un valor de tipo ${receivedType}.`;
                }

                return true;
            });
        };
    }

    function createNotInstanceOfMethod(
        combinedValidator: (valor: unknown) => Type_Validadores_Response_Basic
    ): <T>(clase: new (...args: any[]) => T, mensaje?: string) => Interface_Validadores_InstanceOf {
        return function <T>(
            clase: new (...args: any[]) => T,
            mensaje?: string
        ): Interface_Validadores_InstanceOf {
            return chainable((valor) => {
                const result = combinedValidator(valor);
                if (typeof result === 'string') return result;

                const className = clase.name || 'Clase desconocida';

                if (valor instanceof clase) {
                    return mensaje || `Error: El valor NO debe ser una instancia de ${className}.`;
                }

                return true;
            });
        };
    }


    
    /*RETURN ------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    return chainable(validar) as Interface_Validadores_InstanceOf;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* EXPORT ---------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



export type { Interface_Validadores_InstanceOf };
export const Validadores_InstanceOf = Build_Validadores_InstanceOf();
// usePropTypes/validadores/Validadores_Number.tsx
// Validadores_Number.tsx
import { Consts_Validadores } from "./Constants";
import { Type_Validadores_Response_Basic } from "./Types";



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* INTERFACES -----------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



interface Interface_Validadores_Number {
    /**
     * Valida que el valor sea un número.
     * @param valor - Valor a validar.
     * @returns true si es un número válido, sino un mensaje de error.
     */
    (valor: unknown): Type_Validadores_Response_Basic;

    /**
     * Valida que el valor no sea null ni undefined.
     * @param mensaje - Mensaje de error personalizado (opcional).
     * @returns Función de validación.
     */
    required(mensaje?: string): Interface_Validadores_Number;

    /**
     * Valida que el número sea mayor o igual al valor indicado.
     * @param numero - Valor mínimo permitido.
     * @param mensaje - Mensaje de error personalizado (opcional).
     * @returns Función de validación.
     */
    min(numero: number, mensaje?: string): Interface_Validadores_Number;

    /**
     * Valida que el número sea menor o igual al valor indicado.
     * @param numero - Valor máximo permitido.
     * @param mensaje - Mensaje de error personalizado (opcional).
     * @returns Función de validación.
     */
    max(numero: number, mensaje?: string): Interface_Validadores_Number;

    /**
     * Valida que el número esté dentro del rango especificado.
     * @param min - Límite inferior.
     * @param max - Límite superior.
     * @param mensaje - Mensaje de error personalizado (opcional).
     * @returns Función de validación.
     */
    between(min: number, max: number, mensaje?: string): Interface_Validadores_Number;

    /**
     * Valida que el número sea positivo (> 0).
     * @param mensaje - Mensaje de error personalizado (opcional).
     * @returns Función de validación.
     */
    positive(mensaje?: string): Interface_Validadores_Number;

    /**
     * Valida que el número sea negativo (< 0).
     * @param mensaje - Mensaje de error personalizado (opcional).
     * @returns Función de validación.
     */
    negative(mensaje?: string): Interface_Validadores_Number;

    /**
     * Valida que el número sea entero.
     * @param mensaje - Mensaje de error personalizado (opcional).
     * @returns Función de validación.
     */
    integer(mensaje?: string): Interface_Validadores_Number;

    /**
     * Valida que el número sea múltiplo de otro valor.
     * @param divisor - Número por el cual debe ser divisible.
     * @param mensaje - Mensaje de error personalizado (opcional).
     * @returns Función de validación.
     */
    multipleOf(divisor: number, mensaje?: string): Interface_Validadores_Number;

    /**
     * Tipo de validador.
     * @returns El tipo de validador.
     */
    type: typeof Consts_Validadores.types.number;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* BUILDER --------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



function Build_Validadores_Number(): Interface_Validadores_Number {



    /*MAIN --------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    const validar = (valor: unknown): Type_Validadores_Response_Basic => {
        if (typeof valor !== 'number' || isNaN(valor)) {
            return 'Error: El valor proporcionado no es un número válido.';
        }
        return true;
    };



    /*CHAINABLED BUILDER ------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    function chainable(
        nuevaValidacion: (valor: unknown) => Type_Validadores_Response_Basic
    ): Interface_Validadores_Number {
        const combinedValidator = (valor: unknown): Type_Validadores_Response_Basic => {
            // Primero valida que sea un número
            const baseResult = validar(valor);
            if (typeof baseResult === 'string') return baseResult;

            // Luego aplica la nueva regla
            return nuevaValidacion(valor);
        };

        return Object.assign(combinedValidator, {
            required: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    if (valor === null || valor === undefined) {
                        return mensaje || 'Error: Este campo es requerido.';
                    }

                    return true;
                }),

            min: (numero: number, mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const num = valor as number;
                    if (num < numero) {
                        return mensaje || `Error: Debe ser mayor o igual a ${numero}.`;
                    }

                    return true;
                }),

            max: (numero: number, mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const num = valor as number;
                    if (num > numero) {
                        return mensaje || `Error: Debe ser menor o igual a ${numero}.`;
                    }

                    return true;
                }),

            between: (min: number, max: number, mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const num = valor as number;
                    if (num < min || num > max) {
                        return mensaje || `Error: Debe estar entre ${min} y ${max}.`;
                    }

                    return true;
                }),

            positive: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const num = valor as number;
                    if (num <= 0) {
                        return mensaje || 'Error: Debe ser un número positivo.';
                    }

                    return true;
                }),

            negative: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const num = valor as number;
                    if (num >= 0) {
                        return mensaje || 'Error: Debe ser un número negativo.';
                    }

                    return true;
                }),

            integer: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const num = valor as number;
                    if (!Number.isInteger(num)) {
                        return mensaje || 'Error: Debe ser un número entero.';
                    }

                    return true;
                }),

            multipleOf: (divisor: number, mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const num = valor as number;
                    if (num % divisor !== 0) {
                        return mensaje || `Error: Debe ser múltiplo de ${divisor}.`;
                    }

                    return true;
                }),
            type: Consts_Validadores.types.number,
        }) as Interface_Validadores_Number;
    }



    /*CHAINED METHODS ---------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    // -- no apply



    /*RETURN ------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    return chainable(validar) as Interface_Validadores_Number;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* EXPORT --------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



export type { Interface_Validadores_Number };
export const Validadores_Number = Build_Validadores_Number();
// usePropTypes/validadores/Validadores_Object.tsx
import type { Type_Validadores_Response_Basic, Type_Validadores, Interface_Validadores } from "./Types";
import { Consts_Validadores } from "./Constants";
import { isValidValidators } from "./Utils";



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* TYPES ----------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



// -- no apply



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* INTERFACES -----------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



/**
 * Configuración base para el validador de objetos.
 */
interface Config {
    /**
     * Indica si se permiten claves adicionales no definidas en el esquema.
     * @default false
     */
    strict?: boolean;

    /**
     * Esquema de validación para cada propiedad del objeto.
     */
    shape?: Record<string, (value: unknown) => Type_Validadores_Response_Basic>;

    /**
     * Claves obligatorias que deben estar presentes en el objeto.
     */
    requiredKeys?: string[];

    /**
     * Validaciones para su posterior ejecucion por orden
     */
    validations?: Array<(obj: Record<string, unknown>) => Type_Validadores_Response_Basic>;
}



/**
 * Interfaz principal del validador de objetos.
 *
 * Se puede invocar directamente o encadenar métodos como `.shape()`, `.strict()` etc.
 */
interface Interface_Validadores_Object {
    /**
     * Valida que el valor sea un objeto y cumpla con las condiciones definidas.
     * @param valor - Valor a validar.
     * @returns true si es válido, sino un mensaje de error.
     */
    (valor: unknown): Type_Validadores_Response_Basic;

    /**
     * Define la forma esperada del objeto.
     * @param schema - Objeto donde cada propiedad tiene su propio validador.
     * @returns Función de validación actualizada.
     */
    shape(
        schema: Record<string, (value: unknown) => Type_Validadores_Response_Basic>
    ): Interface_Validadores_Object;

    /**
     * El objeto NO puede tener claves adicionales fuera del esquema definido.
     * @returns Función de validación actualizada.
     */
    strict(): Interface_Validadores_Object;

    /**
     * Marca ciertas claves como obligatorias, incluso si otras son opcionales.
     * @param keys - Lista de claves que deben estar presentes.
     * @returns Función de validación actualizada.
     */
    requiredKeys(keys: string[]): Interface_Validadores_Object;

    /**
     * Tipo de validador.
     */
    type: typeof Consts_Validadores.types.object;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* BUILDER --------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



function Build_Validadores_Object(): Interface_Validadores_Object {

    

    /* MAIN -------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    const validar = (valor: unknown): Type_Validadores_Response_Basic => {
        if (typeof valor !== 'object' || valor === null || Array.isArray(valor)) {
            return 'Error: El valor proporcionado no es un objeto.';
        }
        return true;
    };




    /* CHAINABLE UTILITY ------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    function chainable(
        nuevaValidacion: (valor: unknown) => Type_Validadores_Response_Basic
    ): Interface_Validadores_Object {
        const combinedValidator = (valor: unknown): Type_Validadores_Response_Basic => {
            const baseResult = validar(valor);
            if (typeof baseResult === 'string') return baseResult;
            return nuevaValidacion(valor);
        };

        return Object.assign(combinedValidator, {
            shape: createShapeMethod(combinedValidator),
            strict: createStrictMethod(combinedValidator),
            requiredKeys: createRequiredKeysMethod(combinedValidator),
            type: Consts_Validadores.types.object,
        }) as Interface_Validadores_Object;
    }



    /* CHAINED METHODS --------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    function createShapeMethod(
        combinedValidator: (valor: unknown) => Type_Validadores_Response_Basic
    ) {
        return function (
            schema: Record<string, Interface_Validadores[keyof Interface_Validadores]>
        ): Interface_Validadores_Object {
            // Validamos que los validadores sean válidos
            const validationError = isValidValidators(Object.values(schema));
            if (typeof validationError === 'string') {
                return chainable(() => validationError);
            }

            // Solo guardamos el esquema, sin ejecutar ninguna validación
            config.shape = schema;

            // Continuamos con el flujo encadenable
            return chainable((valor) => {
                const result = combinedValidator(valor);
                if (typeof result === 'string') return result;

                // Aquí ya pueden actuar otros métodos encadenados
                return true;
            });
        };
    }

    function createStrictMethod(
        combinedValidator: (valor: unknown) => Type_Validadores_Response_Basic
    ) {
        return function (): Interface_Validadores_Object {
            return chainable((valor) => {
                const result = combinedValidator(valor);
                if (typeof result === 'string') return result;

                const obj = valor as Record<string, unknown>;
                const schemaKeys = Object.keys(config.shape || {});
                const objKeys = Object.keys(obj);

                // 1. Detectar claves faltantes
                const missingKeys = schemaKeys.filter(key => !objKeys.includes(key));

                // 2. Detectar claves adicionales
                const extraKeys = objKeys.filter(key => !schemaKeys.includes(key));

                // 3. Mostrar errores si hay
                if (missingKeys.length > 0 && extraKeys.length > 0) {
                    return `Error: El objeto tiene claves faltantes y no permitidas. ` +
                        `Faltan: ${missingKeys.join(', ')}. ` +
                        `No permitidas: ${extraKeys.join(', ')}.`;
                }

                if (missingKeys.length > 0) {
                    return `Error: Faltan claves obligatorias: ${missingKeys.join(', ')}.`;
                }

                if (extraKeys.length > 0) {
                    return `Error: El objeto contiene claves no permitidas: ${extraKeys.join(', ')}.`;
                }

                return true;
            });
        };
    }

    function createRequiredKeysMethod(
        combinedValidator: (valor: unknown) => Type_Validadores_Response_Basic
    ) {
        return function (keys: string[]): Interface_Validadores_Object {
            return chainable((valor) => {
                const result = combinedValidator(valor);
                if (typeof result === 'string') return result;

                const obj = valor as Record<string, unknown>;

                const missingKeys = keys.filter(key => !(key in obj));

                if (missingKeys.length > 0) {
                    return `Error: Faltan claves obligatorias: ${missingKeys.join(', ')}.`;
                }

                return true;
            });
        };
    }



    /* CONFIG ---------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////////*/



    const config: Config = {
        strict: false,
        shape: {},
        requiredKeys: [],
    };



    /* UTILS ----------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////////*/



    // -- no apply



    /* RETURN ------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/

    

    return chainable(validar) as Interface_Validadores_Object;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* EXPORT ---------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



export type { Interface_Validadores_Object };
export const Validadores_Object = Build_Validadores_Object();
// usePropTypes/validadores/Validadores_String.tsx
//Validadores_String.tsx
import { Consts_Validadores } from './Constants';
import type { Type_Validadores_Response_Basic } from './Types';



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/*INTERFACES ------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



interface Interface_Validadores_String {
    /** 
     * Valida que el valor sea un string.
     * @param valor - Valor a validar.
     * @returns true si el valor es un string, de lo contrario un mensaje de error.
     */
    (valor: unknown): Type_Validadores_Response_Basic;

    /**
     * Valida que el valor sea un string y no esté vacío.
     * @param valor - Valor a validar.
     * @param mensaje - Mensaje opcional de error si la validación falla. El usuario puede especificar un mensaje personalizado o no
     * @returns true si el valor es un string no vacío, de lo contrario un mensaje de error.
     */
    required(mensaje?: string | undefined): Interface_Validadores_String;

    /**
     * Valida que el valor sea un string y tenga una longitud mínima.
     * @param longitud - Longitud mínima permitida.
     * @param mensaje - Mensaje de error si la validación falla.
     * @returns Función de validación.
     */
    min(longitud: number, mensaje?: string | undefined): Interface_Validadores_String;

    /**
     * Valida que el valor sea un string y tenga una longitud máxima.
     * @param longitud - Longitud máxima permitida.
     * @param mensaje - Mensaje de error si la validación falla.
     * @returns Función de validación.
     */
    max(longitud: number, mensaje?: string | undefined): Interface_Validadores_String;

    /**
     * Valida que el valor sea un string y tenga una longitud exacta.
     * @param longitud - Longitud exacta permitida.
     * @param mensaje - Mensaje de error si la validación falla.
     * @returns Función de validación.
     */
    exact(longitud: number, mensaje?: string | undefined): Interface_Validadores_String;

    /**
     * Valida que el valor sea un string y contenga solo letras.
     * @param valor - Valor a validar.
     * @param mensaje - Mensaje de error si la validación falla.
     * @returns true si el valor es un string con letras, de lo contrario un mensaje de error.
     */
    onlyLetters(mensaje?: string | undefined): Interface_Validadores_String;

    /**
     * Valida que el valor sea un string y contenga solo números.
     * @param valor - Valor a validar.
     * @param mensaje - Mensaje de error si la validación falla.
     * @returns true si el valor es un string con números, de lo contrario un mensaje de error.
     */
    onlyNumbers(mensaje?: string | undefined): Interface_Validadores_String;

    /**
     * Valida que el valor sea un string y contenga solo letras y números.
     * @param valor - Valor a validar.
     * @param mensaje - Mensaje de error si la validación falla.
     * @returns true si el valor es un string con letras y números, de lo contrario un mensaje de error.
     */
    alphanumeric(mensaje?: string | undefined): Interface_Validadores_String;

    /**
     * Valida que el valor sea un string y cumpla con una expresión regular.
     * @param expresion - Expresión regular a validar.
     * @param mensaje - Mensaje de error si la validación falla.
     * @returns Función de validación.
     */
    regex( expresion: RegExp, mensaje?: string | undefined ): Interface_Validadores_String;

    /**
     * Tipo de validador.
     * @returns El tipo de validador.
     */
    type: typeof Consts_Validadores.types.string;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/*BUILDER ---------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



function Build_Validadores_String(): Interface_Validadores_String {



    /*MAIN --------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    const validar = (valor: unknown): Type_Validadores_Response_Basic => {
        if (typeof valor !== 'string') {
            return 'Error: El valor proporcionado no es un string.';
        }
        return true;
    };



    /*CHAINABLED BUILDER ------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    function chainable(
        nuevaValidacion: (valor: unknown) => Type_Validadores_Response_Basic
    ): Interface_Validadores_String {
        const combinedValidator = (valor: unknown): Type_Validadores_Response_Basic => {
            // Primero valida que sea un string
            const baseResult = validar(valor);
            if (typeof baseResult === 'string') return baseResult;

            // Luego aplica la nueva regla
            return nuevaValidacion(valor);
        };

        return Object.assign(combinedValidator, {
            required: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    if (!valor || (typeof valor === 'string' && valor.trim() === '')) {
                        return mensaje || 'Error: Este campo es requerido.';
                    }

                    return true;
                }),

            min: (longitud: number, mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const str = valor as string;
                    if (str.length < longitud) {
                        return mensaje || `Error: Debe tener al menos ${longitud} caracteres.`;
                    }

                    return true;
                }),

            max: (longitud: number, mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const str = valor as string;
                    if (str.length > longitud) {
                        return mensaje || `Error: No puede superar los ${longitud} caracteres.`;
                    }

                    return true;
                }),

            exact: (longitud: number, mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const str = valor as string;
                    if (str.length !== longitud) {
                        return mensaje || `Error: Debe tener exactamente ${longitud} caracteres.`;
                    }

                    return true;
                }),

            onlyLetters: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const str = valor as string;
                    if (!/^[a-zA-Z]+$/.test(str)) {
                        return mensaje || 'Error: Solo se permiten letras.';
                    }

                    return true;
                }),

            onlyNumbers: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const str = valor as string;
                    if (!/^[0-9]+$/.test(str)) {
                        return mensaje || 'Error: Solo se permiten números.';
                    }

                    return true;
                }),

            alphanumeric: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const str = valor as string;
                    if (!/^[a-zA-Z0-9]+$/.test(str)) {
                        return mensaje || 'Error: Solo se permiten letras y números.';
                    }

                    return true;
                }),

            regex: (expresion: RegExp, mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    const str = valor as string;
                    if (!expresion.test(str)) {
                        return mensaje || 'Error: El valor no coincide con el patrón requerido.';
                    }

                    return true;
                }),

            type: Consts_Validadores.types.string,
        }) as Interface_Validadores_String;
    }
    


    /*CHAINED METHODS ---------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    // -- no apply



    /*RETURN ------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    return chainable(validar) as Interface_Validadores_String;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/*EXPORT ----------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/


export type { Interface_Validadores_String };
export const Validadores_String = Build_Validadores_String();
// usePropTypes/validadores/Validadores_Symbol.tsx
import { Consts_Validadores } from './Constants';
import type { Type_Validadores_Response_Basic } from './Types';



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* TYPES ----------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



//-- no apply



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* INTERFACES -----------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



interface Interface_Validadores_Symbol {
    /**
     * Valida que el valor sea exactamente un `symbol`.
     * @param valor - Valor a validar.
     * @returns true si es symbol, sino un mensaje de error.
     */
    (valor: unknown): Type_Validadores_Response_Basic;

    /**
     * Valida que el valor no sea null/undefined y sea `symbol`.
     * @param mensaje - Mensaje opcional de error si falla la validación.
     * @returns Función de validación encadenable.
     */
    required(mensaje?: string): Interface_Validadores_Symbol;

    /**
     * Tipo de validador.
     * @returns El tipo de validador.
     */
    type: typeof Consts_Validadores.types.symbol;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* BUILDER --------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



function Build_Validadores_Symbol(): Interface_Validadores_Symbol {



    /* MAIN -------------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    const validar = (valor: unknown): Type_Validadores_Response_Basic => {
        if (typeof valor !== 'symbol') {
            return 'Error: El valor debe ser `symbol`.';
        }
        return true;
    };



    /* CHAINABLE UTILITY ------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    function chainable(
        nuevaValidacion: (valor: unknown) => Type_Validadores_Response_Basic
    ): Interface_Validadores_Symbol {
        const combinedValidator = (valor: unknown): Type_Validadores_Response_Basic => {
            // Primero valida que sea `symbol`
            const baseResult = validar(valor);
            if (typeof baseResult === 'string') return baseResult;

            // Luego aplica la nueva regla
            return nuevaValidacion(valor);
        };

        return Object.assign(combinedValidator, {
            required: (mensaje?: string) =>
                chainable((valor) => {
                    const result = combinedValidator(valor);
                    if (typeof result === 'string') return result;

                    if (valor === null || valor === undefined) {
                        return mensaje || 'Error: Este campo es requerido.';
                    }

                    return true;
                }),

            type: Consts_Validadores.types.symbol,
        }) as Interface_Validadores_Symbol;
    }



    /* CHAINED METHODS --------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    // -- no apply



    /* RETURN -----------------------------------------------------------------------------------*/
    /*///////////////////////////////////////////////////////////////////////////////////////////*/



    return chainable(validar) as Interface_Validadores_Symbol;
}



/*///////////////////////////////////////////////////////////////////////////////////////////////*/
/* EXPORT ---------------------------------------------------------------------------------------*/
/*///////////////////////////////////////////////////////////////////////////////////////////////*/



export type { Interface_Validadores_Symbol };
export const Validadores_Symbol = Build_Validadores_Symbol();
